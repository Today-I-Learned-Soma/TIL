## 오늘 할일

- [ ]  mock객체 만들기
- [ ]  도메인주도개발 참조해서 mvc모델 구성하기
- [x]  스프링 회의
- [x]  스프링이랑 mysql연동
- [x]  서비스 흐름도에 맞게 구성하기

[시간표]

12:20 ~ 6:30 스프링 mock객체 설정. jar파일 까지 오류없이 생성

6:30 ~ 8:00 휴식

8:00 ~ 1:00 서버 구축(ALB, SQS, S3, EC2위에 spring boot 올리기) → 서비스 흐름도에 맞게 구성하기

## 오늘 배운 것

---

## 즉시 로딩과 지연로딩

- join된 객체의 정보를 가져오고 싶을 때
- 즉시 로딩
    - 한번에 쿼리로 모든 데이터를 가져옴
    - N+1문제 발생
        - 실무에서는 JPQL을 많이 쓰는데, em.find()는 **`한방쿼리로`** 최적화가 가능하지만 만약 select m from Member m 이라고 했을 때 member만 select하게 되고, 즉시 로딩일 때 그 안에 team객체가 있을 시 team과 관련된 sql문이 또 날라가게 된다
            - 각각 N개씩 더 날리게 되는 거니까 엄청난 쿼리가 날아가게 된다.
    - 해결책
        - 지연로딩 사용
        - JPQL의 fetch join 사용
            - 그냥 join
                - 오직 JPQL에서 조회하는 주체가 되는 엔티티만 조회하여 영속화
            - fetch join
                - 조회의 주체가 되는 엔티티  + 연관 엔티티 함께 영속화
- 지연 로딩
    - 조회시에는 프록시 객체를 사용해서 프록시를 조회
    - 사용할때에 실제로 데이터를 가져옴
    - 실무에서 사용
    

## Primary Key 자동생산 전략

- Identity전략
    - 기본 키 생성을 DB에 위임하는 전략
    - DB에 값을 저장하고 나서야 기본 키 값을 구할 수 있을 때 사용
    - 식별자를 조회해서 엔티티의 식별자에 할당
    - mysql, postgresql, h2에서 사용
- Sequence전략
    - 유일한 값을 순서대로 생성하는 DB 오브젝트
    - oracle, prostgresql, h2 db에서 사용
    - 사용코드
        1. DB 시퀀스를 할당해서 식별자를 조회
        2. 조회한 식별자를 엔티티에 할당
        3. 엔티티를 영속성 컨텍스트에 저장 → em.persist(board)
        4. 트랜잭션 커밋
        5. 플러시 - DB에 저장
- Table 전략
    - 키 생성 전용 테이블을 만들고 여기에 이름과 값을 사용할 컬럼을 만들어 DB 시퀀스를 흉내내는 전략
    - 모든 DB에 적용 가능

## [도메인 주도 개발 시작하기]

### 1장. 도메인 모델 시작하기

- 개발자는 코딩에 앞서 요구사항을 올바르게 이해하는 것이 중요

 

<**밸류 타입>**

- 개념적으로 완전한 하나를 표현할 때 사용
    
    ```java
    public class Receiver {
    	private String name;
    	private String phoneNumber;
    }
    ```
    
    → receiver는 그 자체로 `받는 사람을 의미`함
    
    - 장점
        - 의미를 명확하게 표현하기 위해 사용가능
        
        ```java
        public class Money {
        	private int value;
        }
        ```
        
        - 밸류 타입을 위한 기능을 추가 가능
        - 두 밸류 객체를 비교할 때는 모든 속성이 같은지 비교한다.
- 식별자를 위한 밸류 타입을 사용해서 `의미가 잘 드러나도록` 해야 함
    - ex) 주문번호 표현 : 식별자 타입으로 String 대신 OrderNo밸류 타입 사용